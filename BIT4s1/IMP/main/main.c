/**
 * @file main.c (VUT FIT - IMP projekt)
 * 
 * @brief IMP projekt - Analog PulseSensor and OLED display - Heart BPM
 * @date 2022-12-10
 * @author Karel Jirgl (xjirgl01)
 * @update 2022-12-13
 */

#include <string.h>
#include <time.h>

#include "driver/gpio.h"
#include "driver/i2c.h"
#include "esp_err.h"
#include "esp_log.h"
#include "freertos/task.h"
#include "driver/adc.h"
#include "esp_adc_cal.h"

#include "sdkconfig.h" // generated by "make menuconfig"

#include "ssd1366.h"
#include "font8x8_basic.h"
#include "image1.h"
#include "image2.h"


#define tag "IMP projekt"




/* Name: ssd1306-esp-idf-i2c
*  Source: https://github.com/yanbe/ssd1306-esp-idf-i2c/blob/master/main/main.c
*  Date: 2022-12-10
*  Author: yanbe
*  Edited: true
*  License: Apache License 2.0 (https://github.com/yanbe/ssd1306-esp-idf-i2c/blob/master/LICENSE)
*/
#define SDA_PIN GPIO_NUM_21
#define SCL_PIN GPIO_NUM_22

void i2c_master_init()
{
	i2c_config_t i2c_config = {
		.mode = I2C_MODE_MASTER,
		.sda_io_num = SDA_PIN,
		.scl_io_num = SCL_PIN,
		.sda_pullup_en = GPIO_PULLUP_ENABLE,
		.scl_pullup_en = GPIO_PULLUP_ENABLE,
		.master.clk_speed = 1000000
	};
	i2c_param_config(I2C_NUM_0, &i2c_config);
	i2c_driver_install(I2C_NUM_0, I2C_MODE_MASTER, 0, 0, 0);
}

void ssd1306_init() {
	esp_err_t espRc;

	i2c_cmd_handle_t cmd = i2c_cmd_link_create();

	i2c_master_start(cmd);
	i2c_master_write_byte(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);
	i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_CMD_STREAM, true);

	i2c_master_write_byte(cmd, OLED_CMD_SET_CHARGE_PUMP, true);
	i2c_master_write_byte(cmd, 0x14, true);

	i2c_master_write_byte(cmd, OLED_CMD_SET_SEGMENT_REMAP, true); // reverse left-right mapping
	i2c_master_write_byte(cmd, OLED_CMD_SET_COM_SCAN_MODE, true); // reverse up-bottom mapping

	i2c_master_write_byte(cmd, OLED_CMD_DISPLAY_ON, true);
	i2c_master_stop(cmd);

	espRc = i2c_master_cmd_begin(I2C_NUM_0, cmd, 10/portTICK_PERIOD_MS);
	if (espRc == ESP_OK) {
		ESP_LOGI(tag, "OLED configured successfully");
	} else {
		ESP_LOGE(tag, "OLED configuration failed. code: 0x%.2X", espRc);
	}
	i2c_cmd_link_delete(cmd);
}

void task_ssd1306_display_pattern(int state) {
	i2c_cmd_handle_t cmd;

	for (uint8_t i = 0; i < 8; i++) {
		cmd = i2c_cmd_link_create();
		i2c_master_start(cmd);
		i2c_master_write_byte(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);
		i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_CMD_SINGLE, true);
		i2c_master_write_byte(cmd, 0xB0 | i, true);
		i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_DATA_STREAM, true);
		for (uint8_t j = 0; j < 128; j++) {
			//i2c_master_write_byte(cmd, 0xFF >> (j % 8), true);
			i2c_master_write_byte(cmd, 0xFF >> state, true);
			//i2c_master_write_byte(cmd, 3, true);
		}
		i2c_master_stop(cmd);
		i2c_master_cmd_begin(I2C_NUM_0, cmd, 10/portTICK_PERIOD_MS);
		i2c_cmd_link_delete(cmd);
	}
}

void task_ssd1306_display_clear() {
	i2c_cmd_handle_t cmd;

	uint8_t zero[128] = {0};
	for (uint8_t i = 0; i < 8; i++) {
		cmd = i2c_cmd_link_create();
		i2c_master_start(cmd);
		i2c_master_write_byte(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);
		i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_CMD_SINGLE, true);
		i2c_master_write_byte(cmd, 0xB0 | i, true);

		i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_DATA_STREAM, true);
		i2c_master_write(cmd, zero, 128, true);
		i2c_master_stop(cmd);
		i2c_master_cmd_begin(I2C_NUM_0, cmd, 10/portTICK_PERIOD_MS);
		i2c_cmd_link_delete(cmd);
	}
}


void task_ssd1306_display_image(const uint8_t image[]) {
	i2c_cmd_handle_t cmd;

	for (uint8_t i = 0+1; i < 8-1; i++) { // skip first and last row
		cmd = i2c_cmd_link_create();
		i2c_master_start(cmd);
		i2c_master_write_byte(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);
		i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_CMD_SINGLE, true);
		i2c_master_write_byte(cmd, 0xB0 | i, true);
		i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_DATA_STREAM, true);
		for (uint8_t j = 0; j < 128; j++) {
			i2c_master_write_byte(cmd, image[i*128+j], true);
		}
		i2c_master_stop(cmd);
		i2c_master_cmd_begin(I2C_NUM_0, cmd, 10/portTICK_PERIOD_MS);
		i2c_cmd_link_delete(cmd);
	}
}


void task_ssd1306_display_text(const void *arg_text) {
	char *text = (char*)arg_text;
	uint8_t text_len = strlen(text);

	i2c_cmd_handle_t cmd;

	uint8_t cur_page = 0;

	cmd = i2c_cmd_link_create();
	i2c_master_start(cmd);
	i2c_master_write_byte(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);

	i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_CMD_STREAM, true);
	i2c_master_write_byte(cmd, 0x00, true); // reset column
	i2c_master_write_byte(cmd, 0x10, true);
	i2c_master_write_byte(cmd, 0xB0 | cur_page, true); // reset page

	i2c_master_stop(cmd);
	i2c_master_cmd_begin(I2C_NUM_0, cmd, 10/portTICK_PERIOD_MS);
	i2c_cmd_link_delete(cmd);

	for (uint8_t i = 0; i < text_len; i++) {
		if (text[i] == '\n') {
			cmd = i2c_cmd_link_create();
			i2c_master_start(cmd);
			i2c_master_write_byte(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);

			i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_CMD_STREAM, true);
			i2c_master_write_byte(cmd, 0x00, true); // reset column
			i2c_master_write_byte(cmd, 0x10, true);
			i2c_master_write_byte(cmd, 0xB0 | ++cur_page, true); // increment page

			i2c_master_stop(cmd);
			i2c_master_cmd_begin(I2C_NUM_0, cmd, 10/portTICK_PERIOD_MS);
			i2c_cmd_link_delete(cmd);
		} else {
			cmd = i2c_cmd_link_create();
			i2c_master_start(cmd);
			i2c_master_write_byte(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);

			i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_DATA_STREAM, true);
			i2c_master_write(cmd, font8x8_basic_tr[(uint8_t)text[i]], 8, true);

			i2c_master_stop(cmd);
			i2c_master_cmd_begin(I2C_NUM_0, cmd, 10/portTICK_PERIOD_MS);
			i2c_cmd_link_delete(cmd);
		}
	}
}
/* ******* ssd1306-esp-idf-i2c - end ******* */



#define BLINK_GPIO GPIO_NUM_2
uint8_t s_led_state = 0;

void led_init()
{
    gpio_reset_pin(BLINK_GPIO);
    /* Set the GPIO as a push/pull output */
    gpio_set_direction(BLINK_GPIO, GPIO_MODE_OUTPUT);
    ESP_LOGI(tag, "LED GPIO configured!");
}

void blink_led()
{
    /* Toggle the LED state */
	s_led_state = !s_led_state;
    /* Set the GPIO level according to the state (LOW or HIGH)*/
    gpio_set_level(BLINK_GPIO, s_led_state);
}

void sensor_init()
{
	// setup ADC on analog pin (GPIO 34)
	esp_adc_cal_characteristics_t adc1_chars;
    esp_adc_cal_characterize(ADC_UNIT_1, ADC_ATTEN_DB_11, ADC_WIDTH_BIT_DEFAULT, 0, &adc1_chars);
    ESP_ERROR_CHECK(adc1_config_width(ADC_WIDTH_BIT_DEFAULT));
    ESP_ERROR_CHECK(adc1_config_channel_atten(ADC1_CHANNEL_6, ADC_ATTEN_DB_11));
	ESP_LOGI(tag, "PulseSensor GPIO configured!");
}

uint32_t get_clock()
{
    uint32_t clock_millis = (uint32_t) (clock() * 1000 / CLOCKS_PER_SEC);
    //printf("clock_millis: %d\n", clock_millis);
	return clock_millis;
}



static int task_bpm_value = 0;
static int task_fcv_value = 0; // finger calibration value: [3500 >] x [> 2500]
static void *task_img_value = NULL;

void task_display_render(void *ignore)
{
	while(1) {
		if (task_img_value != NULL) {
			task_ssd1306_display_image(task_img_value);
		}
		
		char temp_str[50] = "";
		if (task_bpm_value != 0) {
			sprintf(temp_str, "BPM: %d     \n\n\n\n\n\n\n3500> %d >2500\n", task_bpm_value, task_fcv_value);
		} else {
			sprintf(temp_str, "BPM: --     \n\n\n\n\n\n\n3500> %d >2500\n", task_fcv_value);
		}
		task_ssd1306_display_text(temp_str);

		vTaskDelay(pdMS_TO_TICKS(10));
	}
	
	vTaskDelete(NULL);
}



void app_main(void)
{
	// Init
	i2c_master_init();
	ssd1306_init();
	led_init();
	sensor_init();



	// Display intro
	task_ssd1306_display_clear();
	for(int i = 8; i >= 0; i--){
		task_ssd1306_display_pattern(i);
		vTaskDelay(500/portTICK_PERIOD_MS);
	}
	vTaskDelay(500/portTICK_PERIOD_MS);
	for(int i = 0; i <= 8; i++){
		task_ssd1306_display_pattern(i);
		vTaskDelay(500/portTICK_PERIOD_MS);
	}
	vTaskDelay(500/portTICK_PERIOD_MS);

	task_ssd1306_display_clear(NULL);
	task_ssd1306_display_text("\n\n  PulseSensor\n  ----------\n  IMP projekt\n  FIT VUT 2022\n");
	vTaskDelay(5000/portTICK_PERIOD_MS);



	// Display loop
	task_ssd1306_display_clear(NULL);
	xTaskCreate(&task_display_render, "display_render",  2048, NULL, 6, NULL);



	// Sensor loop
	#define lastDataCount 100
	int lastData[lastDataCount] = {0};
	int lastDataAverage[lastDataCount] = {0};

	const int currentAverageFromSamples = 10; // average from x samples
	int currentAverage = 0;

	const int lastLowestFromSamples = 10; // last lowest from x samples
	int lastLowest = 0;

	
	int beatFound = 0; // only for visualization
	uint32_t beatClockStart = 0; // timestamp of last beat

	const int peakStartSamples = 10;
	const int peakWaitSamples = 20;
	const int peakDifference = 7;
	int peakStart = -1;
	int peakValue = 0;
	int peakWait = 0;


	while(1) {
		// get sensor value
		int value = adc1_get_raw(ADC1_CHANNEL_6);
        //uint32_t voltage = esp_adc_cal_raw_to_voltage(value, &adc1_chars);
		//printf("%d,%d\n",value,voltage);



		// save last x sensor values
		for(int i = lastDataCount-1; i > 0; i--){
			lastData[i] = lastData[i-1];
		}
		lastData[0] = value;


		// get average value from last x samples
		currentAverage = 0;
		for(int i = 0; i < currentAverageFromSamples; i++){
			currentAverage += lastData[i];
		}
		currentAverage /= currentAverageFromSamples;


		// save last x average values
		for(int i = lastDataCount-1; i > 0; i--){
			lastDataAverage[i] = lastDataAverage[i-1];
		}
		lastDataAverage[0] = currentAverage;


		// get lowest average value from x samples
		lastLowest = currentAverage;
		for(int i = 0; i < lastLowestFromSamples; i++){
			if(lastLowest > lastDataAverage[i]){
				lastLowest = lastDataAverage[i];
			}
		}





		beatFound = 0;


		// new peak found
		if(peakStart == -1 && lastDataAverage[0] < lastDataAverage[1]){
			// last 6 average values are ascending
			if(lastDataAverage[1] >= lastDataAverage[2] && lastDataAverage[2] >= lastDataAverage[3] && lastDataAverage[3] >= lastDataAverage[4]
			&& lastDataAverage[4] >= lastDataAverage[5] && lastDataAverage[5] >= lastDataAverage[6] && lastDataAverage[6] >= lastDataAverage[7]
			//&& lastDataAverage[7] >= lastDataAverage[8] && lastDataAverage[8] >= lastDataAverage[9] && lastDataAverage[9] >= lastDataAverage[10]
			//&& lastDataAverage[10] >= lastDataAverage[11] && lastDataAverage[11] >= lastDataAverage[12] && lastDataAverage[12] >= lastDataAverage[13]
			){
				// difference between last lowest average value and current average is more than 7 points
				if(currentAverage-lastLowest > peakDifference) {
					// wait few samples for next peak
					if(peakWait == 0) {
						peakStart = peakStartSamples;
						peakValue = lastDataAverage[1];
						beatFound = 100;
					}
				}
			}
		}

		// wait few samples to check beat
		if(peakStart > 0) {
			peakStart--;

		// check beat from last found peak
		} else if(peakStart == 0) {
			peakStart--;
			//if(lastDataAverage[1] <= lastDataAverage[2] && lastDataAverage[2] <= lastDataAverage[3] && lastDataAverage[3] <= lastDataAverage[4]
			//&& lastDataAverage[4] <= lastDataAverage[5] && lastDataAverage[5] <= lastDataAverage[6] && lastDataAverage[6] <= lastDataAverage[7]
			//&& lastDataAverage[7] <= lastDataAverage[8] && lastDataAverage[8] <= lastDataAverage[9] && lastDataAverage[9] <= lastDataAverage[10]
			//&& lastDataAverage[10] <= lastDataAverage[11] && lastDataAverage[11] <= lastDataAverage[12] && lastDataAverage[12] <= lastDataAverage[13]
			//){
				// difference between peak average value and current average is more than 7 points
				if(peakValue-lastLowest > peakDifference) {

					blink_led();
					task_bpm_value = 60000/(get_clock()-beatClockStart);
					task_fcv_value = value;
					task_img_value = (void*)image_data_image2;
					
					printf("BPM: %d (finger calibration value: [3500 >] %d [> 2500])\n", 60000/(get_clock()-beatClockStart), value);
					
					beatClockStart = get_clock();
					peakWait = peakWaitSamples;
					beatFound = 100;
				}
			//}
		}

		// wait few samples for next peak
		if(peakWait > 0) {
			peakWait--;
			if(peakWait == 0) {
				// reset LED and heart image
				blink_led();
				task_img_value = (void*)image_data_image1;
			}
		}

		// beat not found for more than 10 seconds
		if(get_clock()-beatClockStart > 10000) { // 10 seconds
			task_bpm_value = 0;
			task_fcv_value = value;

			printf("BPM: (unknown) (finger calibration value: [3500 >] %d [> 2500])\n", value);

			beatClockStart = get_clock();
		}
	

		
		// Visualization in serial plotter
		//printf("%d,%d,%d\n", value, currentAverage, currentAverage+beatFound);
        
		vTaskDelay(pdMS_TO_TICKS(10));
	}	
}
